# Brainstorming Session Results

**Session Date:** 2025-11-20
**Facilitator:** Brainstorming Facilitator
**Participant:** BMad

## Session Start

**접근 방식:** AI 추천 기법 + 랜덤 선택 + 점진적 흐름 조합

**목표:** 워크플로우 오케스트레이터 에이전트 설계
- BMM 워크플로우를 자동으로 진행
- 각 단계 완료 후 party-mode로 자동 리뷰
- 워크플로우 상태를 추적하고 다음 단계 자동 실행

## Executive Summary

**Topic:** 워크플로우 오케스트레이터 에이전트 - 자동 진행 & 자동 리뷰 기능

**Session Goals:** 에이전트의 정체성, 기능, 페르소나 발견

**Techniques Used:**
1. First Principles Thinking (창의적 사고)
2. Six Thinking Hats (구조적 분석)
3. Emotion Orchestra (랜덤 선택)
4. Role Playing (이해관계자 관점)

**Total Ideas Generated:** 30+ 기능 아이디어

### Key Themes Identified:
1. **완전 자동화** - 사용자 개입 최소화
2. **품질 보장** - Party-mode 자동 리뷰
3. **End-to-End** - 시작부터 끝까지 한 에이전트
4. **신뢰성** - 상태 추적 및 검증

## Technique Sessions

### Technique 1: First Principles Thinking (창의적 사고)

**근본적 사실들:**
1. 지금 해야 할 워크플로우를 식별해야 한다
2. 오류를 미리 방지해야 한다
3. 작업을 끝까지 완료해야 한다

**핵심 메커니즘:**
- 현재 상태 파악 → `bmm-workflow-status.yaml` 읽기
- 오류 방지 → Party-mode + 프로젝트 구조 분석 (`.bmad/`, `.claude/`, `docs/`)
- 완료 보장 → 워크플로우 종료 시 자연스럽게 완료

**최소 필수 흐름:**
```
상태 파일 읽기 → 다음 워크플로우 찾기 → 실행 → Party-mode 리뷰 → 완료 표시 → 반복
```

**핵심 통찰:**
- 복잡한 AI 판단보다 YAML 상태 파일 기반 단순 로직
- GitHub 레포 참조 가능하지만 로컬 `.bmad/` 구조가 신뢰 소스
- Party-mode는 품질 게이트 역할 - 각 워크플로우 후 자동 리뷰

---

### Technique 2: Six Thinking Hats (구조적 분석)

#### 🤍 White Hat (사실)
- `bmm-workflow-status.yaml` 파일로 진행 상태 추적
- Party-mode 기능 존재
- 워크플로우 명령어 형식: `/bmad:bmm:workflows:xxx`

#### ❤️ Red Hat (감정/직감)
**사용자 핵심 니즈:**
- 한 단계 끝났을 때 기존 코드와 결과물이 일치하는지 검증
- 현재 상황에서 필요한 게 뭔지 정확히 파악
- 다음 올바른 명령어를 자동으로 실행

**감정적 가치:**
- 신뢰성: "제대로 하고 있는지 확신"
- 효율성: "생각 안하고 자동으로 진행"
- 안전성: "오류 없이 끝까지"

#### 💛 Yellow Hat (이점)
**이 오케스트레이터의 장점:**
- ✅ 컨텍스트 일관성: 기존 코드/문서와 항상 싱크
- ✅ 인지 부하 감소: "다음 뭐지?" 고민 제거
- ✅ 품질 보장: 매 단계 검증 후 진행
- ✅ 워크플로우 완주율 향상: 중간에 멈추지 않음

#### 🖤 Black Hat (리스크)
**리스크 분석:**
- ❌ "워크플로우 실패" 개념 제거 → Party-mode가 품질 검증
- ✅ 시간 제약 없음 → 완료가 우선, 속도는 부차적
- ✅ 사용자 개입 불필요 → 완전 자동화 모드
- ⚠️ 진짜 리스크: 상태 파일 손상 또는 불일치

**해결책:**
- 상태 파일 백업 메커니즘
- Party-mode에서 심각한 문제 발견 시 일시 정지 옵션

#### 💚 Green Hat (창의성)
다음 기법에서 창의적 아이디어 발산 예정

---

### Technique 3: Emotion Orchestra (랜덤 선택)

#### 😤 화난 관점: "이게 왜 이렇게 복잡해!"
**화난 개발자의 요구:**
- "상태 한 눈에 보여줘!"
- "명령어 자동으로 쳐줘!"
- "뭐가 문제인지 바로 알려줘!"
- "내가 신경 쓸 필요 없게 해!"

**핵심 기능 도출:**
- 📊 상태 대시보드 자동 출력
- ⚡ 명령어 자동 실행 (물어보지 말고)
- 🚨 문제 즉시 리포트
- 🤖 완전 자동화 모드

#### 😊 즐거운 관점: "진행되는 게 재밌어!"
**즐거운 사용자의 욕구:**
- "워크플로우 진행 실시간으로 보고 싶어!"
- "각 단계 완료될 때마다 성취감!"
- "전체 그림에서 내 위치 보기!"

**UX 기능 도출:**
- 🎯 진행 상황 비주얼 (Progress Bar)
- 🎉 단계 완료 알림 (Celebration)
- 🗺️ 전체 로드맵 보기

#### 😨 두려운 관점: "뭔가 잘못되면 어쩌지?"
**불안한 사용자의 걱정:**
- "자동으로 진행하는데 이상한 방향으로 가면?"
- "Party-mode가 문제 못 찾으면?"
- "돌이킬 수 없는 실수하면?"

**안전장치 기능:**
- 🔄 자동 백업 (각 단계 전)
- 🛡️ Party-mode 멀티 에이전트 검증
- ⏪ 롤백 기능
- 📝 모든 결정 로그 저장

**조화로운 결론:**
모든 감정을 만족시키는 오케스트레이터:
- 😤 화남 → 자동화로 스트레스 제거
- 😊 즐거움 → 진행 시각화로 성취감
- 😨 두려움 → 안전장치로 신뢰 구축

---

### Technique 4: Role Playing (이해관계자 관점)

#### 👔 PM (Product Manager) 관점
**PM의 니즈:**
- "PRD 작성 후 다음은 뭐지? UX? Architecture?" → 자동으로 판단
- "이전 단계 결과물 제대로 됐나?" → Party-mode 검증
- "팀에게 진행 상황 공유" → 상태 리포트 자동 생성

**PM용 기능:**
- 🎯 자동 워크플로우 라우팅 (조건 분기)
- ✅ 품질 게이트 (Party-mode)
- 📊 진행 상황 리포트 생성

#### 🏗️ Architect 관점
**Architect의 니즈:**
- "PRD와 UX가 제대로 정의됐나?" → 의존성 검증
- "Architecture 작성 후 Epic 생성 자동으로" → 자동 다음 단계
- "기술적 일관성 체크" → Party-mode 기술 리뷰

**Architect용 기능:**
- 🔗 선행 아티팩트 검증 (의존성 체크)
- 🔄 자동 후속 워크플로우 트리거
- 🔍 기술 스택 일관성 검증

#### 💻 Developer 관점
**Developer의 니즈:**
- "Epic과 Story가 준비됐나? 바로 코딩 시작" → 준비 상태 확인
- "Story 완료하면 다음 Story 자동으로" → 자동 큐잉
- "테스트 통과했는지 확인" → 자동 검증

**Developer용 기능:**
- ✅ 구현 준비 상태 체크 (모든 선행 완료)
- 🔁 Story 자동 큐 관리
- 🧪 테스트/빌드 자동 실행 및 검증

**통합 통찰:**
모든 역할이 공통으로 원하는 것:
1. **자동화** - 생각 안하고 진행
2. **검증** - 제대로 됐는지 확인
3. **가시성** - 어디까지 왔는지 알기

---

## 💎 아이디어 수렴 및 분류

### 🚀 즉시 구현 (Quick Wins)
1. **상태 파일 읽기** - bmm-workflow-status.yaml 파싱
2. **다음 워크플로우 찾기** - status: "required"/"optional" 찾기
3. **자동 명령어 실행** - `/bmad:bmm:workflows:xxx` 실행
4. **진행 상황 표시** - Phase X / Step Y

### 🔮 개발 필요 (Future Innovations)
1. **Party-mode 자동 리뷰** - 각 워크플로우 후 자동 호출
2. **의존성 검증** - 선행 아티팩트 체크
3. **자동 백업** - 각 단계 전 스냅샷
4. **상태 리포트 생성** - 진행 현황 문서

### 🌙 혁신적 기능 (Moonshots)
1. **롤백 기능** - 이전 단계로 복구
2. **조건 분기 라우팅** - UI 있으면 UX, 없으면 skip
3. **멀티 프로젝트 관리** - 여러 프로젝트 동시 오케스트레이션

### ⭐ **게임 체인저 아이디어**
**"프로젝트 초기화부터 구현 완료까지 단 하나의 에이전트"**

**의미:**
- workflow-init 단계부터 이 에이전트가 시작
- 프로젝트 셋업 → Discovery → Planning → Solutioning → Implementation
- **사용자는 에이전트 하나만 호출, 나머지는 자동**

**구현 방법:**
1. workflow-init 기능 통합 (또는 자동 호출)
2. bmm-workflow-status.yaml 없으면 생성부터 시작
3. 전체 프로젝트 라이프사이클 관리

**임팩트:**
🎯 BMad를 처음 쓰는 사람도 하나의 명령어로 끝까지!

---

## 🎯 액션 플랜 - Top 3 우선순위

### #1 Priority: 전체 프로젝트 라이프사이클 자동 관리

**근거:**
- 사용자 경험 혁명: 하나의 명령어로 모든 것
- BMad 진입 장벽 완전 제거
- "생각 없이" 프로젝트 완성

**다음 단계:**
1. workflow-init 로직 통합 또는 자동 호출
2. bmm-workflow-status.yaml 자동 생성/감지
3. Phase 0 (Discovery) → Phase 3 (Implementation) 자동 흐름
4. 각 phase 간 전환 로직 구현

**필요 리소스:**
- bmm-workflow-status.yaml 구조 이해
- workflow-init 코드 분석
- 각 워크플로우 명령어 맵핑

**타임라인:**
핵심 MVP 먼저, 그 다음 점진적 개선

### #2 Priority: Party-mode 자동 리뷰 시스템

**근거:**
- 품질 보장의 핵심
- "제대로 됐나?" 걱정 제거
- 모든 이해관계자가 원하는 검증

**다음 단계:**
1. 각 워크플로우 완료 후 party-mode 자동 호출
2. party-mode 결과 파싱 및 분석
3. 심각한 이슈 발견 시 일시 정지 로직
4. 리뷰 결과를 상태 파일에 기록

**필요 리소스:**
- party-mode 호출 방법 분석
- 리뷰 결과 구조 이해
- 이슈 심각도 판단 기준

**타임라인:**
워크플로우 자동 진행 후 통합

### #3 Priority: 상태 파일 기반 워크플로우 자동 진행

**근거:**
- 모든 자동화의 기반
- 명확한 로직: YAML 읽기 → 명령어 실행
- 빠르게 구현 가능

**다음 단계:**
1. bmm-workflow-status.yaml 파서 구현
2. "required"/"optional" 상태 식별
3. 다음 워크플로우 자동 선택 로직
4. `/bmad:bmm:workflows:xxx` 자동 실행
5. 완료 후 상태 업데이트

**필요 리소스:**
- YAML 파싱 라이브러리
- 워크플로우 명령어 리스트
- 상태 업데이트 메커니즘

**타임라인:**
첫 번째로 구현 (다른 기능들의 토대)

---

## 핵심 테마 및 인사이트

### 🎨 주요 테마
1. **완전 자동화** - 사용자 개입 최소화
2. **품질 보장** - Party-mode 자동 리뷰
3. **End-to-End** - 시작부터 끝까지 한 에이전트
4. **신뢰성** - 상태 추적 및 검증

### 💡 핵심 인사이트
- "실패" 개념 제거 → Party-mode가 품질 게이트
- 속도보다 완성도 → 오래 걸려도 끝까지
- 단순성의 힘 → YAML 기반 명확한 로직
- 게임 체인저 → 하나의 명령어로 전체 프로젝트

### 🔮 혁신 포인트
**기존:** 사용자가 각 단계마다 에이전트/명령어 선택
**새로운:** 하나의 오케스트레이터가 처음부터 끝까지 자동 진행

---

## 세션 회고

### ✅ 잘 된 점
- First Principles로 본질 발견: "상태 파악 → 실행 → 검증 → 반복"
- 감정 오케스트라로 사용자 니즈의 모든 측면 탐색
- Role Playing으로 실제 사용 시나리오 구체화
- 게임 체인저 아이디어 발견: "처음부터 끝까지 하나의 에이전트"

### 🔍 더 탐색할 영역
- 에이전트 페르소나 및 커뮤니케이션 스타일
- 에이전트 이름 및 아이덴티티
- 구체적인 명령어 메뉴 구조
- 에러 핸들링 및 예외 상황 처리

### 💡 다음 세션 추천
- 에이전트 페르소나 디자인 (커뮤니케이션 스타일 선택)
- 기술 아키텍처 설계 (구현 방법 상세화)
- 사용자 시나리오 테스트 (실제 사용 흐름 검증)

### 🎯 핵심 질문들
1. 에이전트의 이름과 정체성은?
2. 사용자와 어떤 톤으로 대화할 것인가?
3. 첫 실행 시 사용자 경험은?
4. 오류 상황에서 어떻게 반응할 것인가?

---

_세션은 BMAD CIS 브레인스토밍 프레임워크로 진행되었습니다_
